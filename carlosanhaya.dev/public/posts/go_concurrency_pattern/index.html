<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[Go] Patterns de Concorrência | Carlos Anhaya</title><meta name=keywords content="golang,concurrency"><meta name=description content="Patterns de concorrência seguindo abordagem do livro Concurrency in Go"><meta name=author content="Carlos Anhaya"><link rel=canonical href=https://canonical.url/to/page><link crossorigin=anonymous href=/assets/css/stylesheet.d7fb4cbf980fe688a21621b06a795933c4e6bb2d4070ec940667af1715d84af2.css integrity="sha256-1/tMv5gP5oiiFiGwanlZM8Tmuy1AcOyUBmevFxXYSvI=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://carlosanhaya.dev/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://carlosanhaya.dev/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://carlosanhaya.dev/favicon-32x32.png><link rel=apple-touch-icon href=https://carlosanhaya.dev/apple-touch-icon.png><link rel=mask-icon href=https://carlosanhaya.dev/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="[Go] Patterns de Concorrência"><meta property="og:description" content="Patterns de concorrência seguindo abordagem do livro Concurrency in Go"><meta property="og:type" content="article"><meta property="og:url" content="https://carlosanhaya.dev/posts/go_concurrency_pattern/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-08-09T00:00:00+00:00"><meta property="article:modified_time" content="2022-08-09T00:00:00+00:00"><meta property="og:site_name" content="carlosanhaya.dev"><meta name=twitter:card content="summary"><meta name=twitter:title content="[Go] Patterns de Concorrência"><meta name=twitter:description content="Patterns de concorrência seguindo abordagem do livro Concurrency in Go"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://carlosanhaya.dev/posts/"},{"@type":"ListItem","position":2,"name":"[Go] Patterns de Concorrência","item":"https://carlosanhaya.dev/posts/go_concurrency_pattern/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[Go] Patterns de Concorrência","name":"[Go] Patterns de Concorrência","description":"Patterns de concorrência seguindo abordagem do livro Concurrency in Go","keywords":["golang","concurrency"],"articleBody":"Hi There!\nEstou estudando o livro “Concurrency in Go”, e hoje vou compartilhar aqui algumas coisas que pra mim são importantes do capítulo sobre patterns de concorrência, e claro, com minhas palavras.\nEste texto só faz sentido para quem já sabe um pouco de Go, conhece channel, mutex e entende a diferença entre concorrência e paralelismo. Alguns patterns que irei descrever são conhecidos no mercado e às vezes até utilizam outros nomes, outros na minha opinião nem vem a ser patterns mas sim um conceito para entender outros patterns. Não fique preso a isso, entenda a usabilidade de cada um a fim de identificar um cenário que poderia ser resolvido com determinado pattern ou técnica.\nConfinement\nÉ sobre garantir que uma informação só é acessível por um processo concorrente, como quando usamos mutex.lock() / mutex.unlock(), mas aqui a idéia é garantir que seja concurrent safe sem precisar usar memory synchronization (e.g mutex). Existem dois tipos possíveis desse “confinamento”, ad hoc e lexical.\nad hoc, basicamente aqui você tem um doc. (best practices) que diz que você (programador) não pode expor informação que não deve ser exposta.\nlexical, basicamente aqui você expõe somente aquilo que é necessário expor, fazendo assim a informação ser concurrent safe\nhttps://github.com/anhaya/concurrency-with-go/blob/main/confinement/main.go. for-select\nQuando você tem um select (https://go.dev/ref/spec#Select_statements) sem um default case, isso é block até que entre em algum case. O for com select é utilizado normalmente quando você deseja que caia em mais de um case. Imagine o seguinte cenário, Você precisa chamar 3 APIs de forma concorrente e aguardar o resultado delas, suponha que uma delas dá erro e você precise interromper essa espera.\nhttps://github.com/anhaya/concurrency-with-go/blob/main/forselect/main.go Preventing Goroutine leaks\nGoroutine não são garbage collected. É difícil entender isso sem ter um pouco de base sobre stack, heap e garbage collector, para isso recomendo este vídeo: https://www.youtube.com/watch?v=ZMZpH4yT7M0, lembrando que a idéia de stack, heap e garbage collector é independente da linguagem, mas cada uma lida com isso de uma maneira diferente, pode ser que quando você estiver lendo este texto, o Go gerencie memória de goroutines de uma forma diferente da que é feita hoje na versão 1.18. Mas o que vem a ser goroutine leak?\nVamos supor que você tenha uma goroutine, essa goroutine chama uma API que faz um processamento de qualquer coisa e não retorna nada, e você como desenvolvedor não toma precaução de colocar algum timeout para essa chamada, percebeu o problema né? O que aconteceria é que sua goroutine iria ficar executando mais do que necessário e consequentemente seu programa iria consumir mais memória do que o necessário.\nhttps://github.com/anhaya/concurrency-with-go/blob/main/goroutineleak/main.go The Or-Channel\nBasicamente este pattern implementa um cenário onde você precisa chamar várias funções e parar todas de uma vez quando uma delas feche o próprio channel. Se você não usasse esse pattern você teria que fazer um select case para o channel de cada função, funcionaria, mas com esta implementação o código fica bem mais limpo.\nO algoritmo basicamente é recursivo, olhe o código que é mais fácil do que eu descrever. Eu particularmente tentei pensar em vários cenários em que isso se encaixasse mas não consegui, para cada um que eu elaborava não iria fazer sentido seguir com esse pattern, talvez porque minha experiência está muito limitada com APIs. Se você encontrou um cenário onde isso parecia fazer sentido, por favor, faça um PR que eu atualizo o texto aqui.\nhttps://github.com/anhaya/concurrency-with-go/blob/main/orchannel/main.go. Error handling\nVocê precisa chamar 2 APIs e verificar se as duas retornaram com sucesso, como você faria? Essa abordagem de identificar erros que são tratados na goroutine é bem comum e você irá encontrar algo muito semelhante na internet. A ideia principal desta abordagem é, se sua goroutine tem a possibilidade de retornar um erro, então este erro deve estar no mesmo channel que você coloca o seu resultado com sucesso.\nhttps://github.com/anhaya/concurrency-with-go/blob/main/errorhandling/main.go Pipeline\nPipeline nada mais é do que uma série de etapas onde a saída de cada etapa é a entrada da próxima, essas etapas é o que chamamos de stage. Exemplo, imagine uma pipeline da sua aplicação que tem o objetivo de fazer um deploy no k8s, para isso precisamos rodar a suite de testes, fazer o build, gerar imagem e fazer deploy (fui bem simplista mas é só pra passar a idéia), cada passo desse é o que chamamos de stage e cada passo seguinte depende do anterior.\nSe uma pipeline consiste em um processo sequencial de várias etapas onde a saída de um é a entrada de outro, como isso se encaixa em um pattern de concorrência? O pattern de pipeline com concorrência no Go consiste basicamente de que cada stage terá como saída um channel cujo qual será usado como entrada no próximo stage. Cenário hipotético em que você poderia utilizar pattern de pipeline:\n1 - Você precisa ler um arquivo txt onde cada linha contém a informação de organização e repositório, separados por vírgula. Cada linha demora 1 segundo para ler.\n2 - Para cada linha você deve transformá-los em upper case. Cada linha demora 1 segundo para fazer o upper case.\n3 - Com os dados restantes você deve checar se a organização e repositório é válida, se não for você deve remover essa informação. Cada validação demora 1 segundo.\nO arquivo contém 15 linhas, como você faria esta implementação? Provavelmente seu primeiro pensamento foi criar uma função que lê o arquivo todo e armazena num slice, outra que transforma todo o slice em upper case e outra que valida se organização e repositório são válidos e executá-las de maneira sequencial. Vai funcionar, mas como cada linha leva 1 segundo para ser lida, 1 segundo para ser processada e 1 segundo para ser validada, provavelmente sua pipeline irá demorar 45 segundos.\nExecutando com pattern de pipeline a média é de 17 segundos, ou seja, como o pattern sua pipeline iria ser executada ~3 vezes mais rápida, interessante né?\nEste pattern de pipeline não é a única maneira de implementar um processo sequencial com várias etapas, talvez o seu cenário seja preciso usar workers, fila ou qualquer outro pattern. Sempre avalie outras maneiras.\nhttps://github.com/anhaya/concurrency-with-go/blob/main/pipeline/main.go Fan-in/Fan-out\nImagine a seguinte situação: você precisa gerar métrica de um ano\nCada mês demora 1 segundo para obter os dados Cada mês demora 4 segundos para ser calculado Um mês não depende do outro Como você implementaria?\nSolução 1: Eu poderia obter os dados de todos os meses e em seguida faria o cálculo em cima dos resultados. Partindo das premissas acima eu levaria 1 min (12s + 48s) para concluir.\nSolução 2: Eu poderia usar uma estratégia de Pipeline aqui, ou seja, ao obter o resultado de um mês eu já começo a calcular de maneira concorrente. Parece bom, melhor que a solução 1.\nSolução 3: Eu poderia remodelar a solução 2, usando a estratégia de Pipeline junto com a de Fanin/Fanout. Ou seja, ao invés de usar somente um worker para fazer o cálculo eu irei usar 4 workers (número aleatório, pode ser mais ou pode ser menos), iniciar mais de um worker para fazer o trabalho é o que chamamos de FanOut, após isso eu junto o resultado disso em um channel só, isso é o que chamamos de FanIn. Em alguns lugares também vemos a mesma abordagem mas como o mesmo nome, coisas como “worker pool pattern”.\nhttps://github.com/anhaya/concurrency-with-go/blob/main/fainfanout/main.go Referência\nhttps://austburn.me/blog/a-better-fan-in-fan-out-example.html\n","wordCount":"1218","inLanguage":"en","datePublished":"2022-08-09T00:00:00Z","dateModified":"2022-08-09T00:00:00Z","author":{"@type":"Person","name":"Carlos Anhaya"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://carlosanhaya.dev/posts/go_concurrency_pattern/"},"publisher":{"@type":"Organization","name":"Carlos Anhaya","logo":{"@type":"ImageObject","url":"https://carlosanhaya.dev/favicon.ico"}}}</script></head><body class=dark id=top><header class=header><nav class=nav><div class=logo><a href=https://carlosanhaya.dev/ accesskey=h title="Carlos Anhaya (Alt + H)">Carlos Anhaya</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://carlosanhaya.dev/archives/ title=Posts><span>Posts</span></a></li><li><a href=https://carlosanhaya.dev/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://carlosanhaya.dev/>Home</a>&nbsp;»&nbsp;<a href=https://carlosanhaya.dev/posts/>Posts</a></div><h1 class=post-title>[Go] Patterns de Concorrência</h1><div class=post-description>Patterns de concorrência seguindo abordagem do livro Concurrency in Go</div><div class=post-meta><span title='2022-08-09 00:00:00 +0000 UTC'>August 9, 2022</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Carlos Anhaya&nbsp;|&nbsp;<a href=https://github.com/anhaya/carlosanhaya.dev/tree/main/carlosanhaya.dev/content/posts/go_concurrency_pattern.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p>Hi There!</p><p>Estou estudando o livro <em>&ldquo;Concurrency in Go&rdquo;,</em> e hoje vou compartilhar aqui algumas coisas que pra mim são importantes do capítulo sobre patterns de concorrência, e claro, com minhas palavras.</p><p>Este texto só faz sentido para quem já sabe um pouco de Go, conhece channel, mutex e entende a diferença entre concorrência e paralelismo. Alguns patterns que irei descrever são conhecidos no mercado e às vezes até utilizam outros nomes, outros na minha opinião nem vem a ser <em>patterns</em> mas sim um conceito para entender outros <em>patterns.</em> Não fique preso a isso, entenda a usabilidade de cada um a fim de identificar um cenário que poderia ser resolvido com determinado pattern ou técnica.</p><p><strong>Confinement</strong></p><p>É sobre garantir que uma informação só é acessível por um processo concorrente, como quando usamos mutex.lock() / mutex.unlock(), mas aqui a idéia é garantir que seja <em>concurrent safe</em> sem precisar usar <em>memory synchronization (e.g mutex).</em> Existem dois tipos possíveis desse &ldquo;confinamento&rdquo;, <em>ad hoc</em> e <em>lexical.</em></p><p><em>ad hoc,</em> basicamente aqui você tem um doc. (<em>best practices)</em> que diz que você (programador) não pode expor informação que não deve ser exposta.</p><p><em>lexical,</em> basicamente aqui você expõe somente aquilo que é necessário expor, fazendo assim a informação ser <em>concurrent safe</em></p><ul><li><a href=https://github.com/anhaya/concurrency-with-go/blob/main/confinement/main.go>https://github.com/anhaya/concurrency-with-go/blob/main/confinement/main.go</a>.</li></ul><p><strong>for-select</strong></p><p>Quando você tem um select (<a href=https://go.dev/ref/spec#Select_statements>https://go.dev/ref/spec#Select_statements</a>) sem um default case, isso é block até que entre em algum case. O <em>for</em> com <em>select</em> é utilizado normalmente quando você deseja que caia em mais de um case. Imagine o seguinte cenário, Você precisa chamar 3 APIs de forma concorrente e aguardar o resultado delas, suponha que uma delas dá erro e você precise interromper essa espera.</p><ul><li><a href=https://github.com/anhaya/concurrency-with-go/blob/main/forselect/main.go>https://github.com/anhaya/concurrency-with-go/blob/main/forselect/main.go</a></li></ul><p><strong>Preventing Goroutine leaks</strong></p><p>Goroutine não são <em>garbage collected.</em> É difícil entender isso sem ter um pouco de base sobre <em>stack</em>, <em>heap</em> e <em>garbage collector</em>, para isso recomendo este vídeo: <a href="https://www.youtube.com/watch?v=ZMZpH4yT7M0">https://www.youtube.com/watch?v=ZMZpH4yT7M0</a>, lembrando que a idéia de <em>stack, heap e garbage collector</em> é independente da linguagem, mas cada uma lida com isso de uma maneira diferente, pode ser que quando você estiver lendo este texto, o Go gerencie memória de goroutines de uma forma diferente da que é feita hoje na versão 1.18. Mas o que vem a ser goroutine leak?</p><p>Vamos supor que você tenha uma goroutine, essa goroutine chama uma API que faz um processamento de qualquer coisa e não retorna nada, e você como desenvolvedor não toma precaução de colocar algum timeout para essa chamada, percebeu o problema né? O que aconteceria é que sua goroutine iria ficar executando mais do que necessário e consequentemente seu programa iria consumir mais memória do que o necessário.</p><ul><li><a href=https://github.com/anhaya/concurrency-with-go/blob/main/goroutineleak/main.go>https://github.com/anhaya/concurrency-with-go/blob/main/goroutineleak/main.go</a></li></ul><p><strong>The Or-Channel</strong></p><p>Basicamente este <em>pattern</em> implementa um cenário onde você precisa chamar várias funções e parar todas de uma vez quando uma delas feche o próprio channel. Se você não usasse esse <em>pattern</em> você teria que fazer um select case para o channel de cada função, funcionaria, mas com esta implementação o código fica bem mais limpo.</p><p>O algoritmo basicamente é recursivo, olhe o código que é mais fácil do que eu descrever. Eu particularmente tentei pensar em vários cenários em que isso se encaixasse mas não consegui, para cada um que eu elaborava não iria fazer sentido seguir com esse <em>pattern</em>, talvez porque minha experiência está muito limitada com APIs. Se você encontrou um cenário onde isso parecia fazer sentido, por favor, faça um PR que eu atualizo o texto aqui.</p><ul><li><a href=https://github.com/anhaya/concurrency-with-go/blob/main/orchannel/main.go>https://github.com/anhaya/concurrency-with-go/blob/main/orchannel/main.go</a>.</li></ul><p><strong>Error handling</strong></p><p>Você precisa chamar 2 APIs e verificar se as duas retornaram com sucesso, como você faria?
Essa abordagem de identificar erros que são tratados na goroutine é bem comum e você irá encontrar algo muito semelhante na internet. A ideia principal desta abordagem é, se sua goroutine tem a possibilidade de retornar um erro, então este erro deve estar no mesmo <em>channel</em> que você coloca o seu resultado com sucesso.</p><ul><li><a href=https://github.com/anhaya/concurrency-with-go/blob/main/errorhandling/main.go>https://github.com/anhaya/concurrency-with-go/blob/main/errorhandling/main.go</a></li></ul><p><strong>Pipeline</strong></p><p>Pipeline nada mais é do que uma série de etapas onde a saída de cada etapa é a entrada da próxima, essas etapas é o que chamamos de stage. Exemplo, imagine uma <em>pipeline</em> da sua aplicação que tem o objetivo de fazer um deploy no k8s, para isso precisamos rodar a suite de testes, fazer o build, gerar imagem e fazer deploy (fui bem simplista mas é só pra passar a idéia), cada passo desse é o que chamamos de <em>stage</em> e cada passo seguinte depende do anterior.</p><p>Se uma pipeline consiste em um processo sequencial de várias etapas onde a saída de um é a entrada de outro, como isso se encaixa em um <em>pattern</em> de concorrência? O <em>pattern</em> de <em>pipeline</em> com concorrência no Go consiste basicamente de que cada <em>stage</em> terá como saída um channel cujo qual será usado como entrada no próximo <em>stage</em>. Cenário hipotético em que você poderia utilizar <em>pattern</em> de pipeline:</p><p><em>1 - Você precisa ler um arquivo txt onde cada linha contém a informação de organização e repositório, separados por vírgula. Cada linha demora 1 segundo para ler.</em></p><p><em>2 - Para cada linha você deve transformá-los em upper case. Cada linha demora 1 segundo para fazer o upper case.</em></p><p><em>3 - Com os dados restantes você deve checar se a organização e repositório é válida, se não for você deve remover essa informação. Cada validação demora 1 segundo.</em></p><p>O arquivo contém 15 linhas, como você faria esta implementação? Provavelmente seu primeiro pensamento foi criar uma função que lê o arquivo todo e armazena num slice, outra que transforma todo o slice em upper case e outra que valida se organização e repositório são válidos e executá-las de maneira sequencial. Vai funcionar, mas como cada linha leva 1 segundo para ser lida, 1 segundo para ser processada e 1 segundo para ser validada, provavelmente sua pipeline irá demorar 45 segundos.</p><p>Executando com <em>pattern</em> de <em>pipeline</em> a média é de 17 segundos, ou seja, como o <em>pattern</em> sua pipeline iria ser executada ~3 vezes mais rápida, interessante né?</p><p>Este <em>pattern de pipeline</em> não é a única maneira de implementar um processo sequencial com várias etapas, talvez o seu cenário seja preciso usar workers, fila ou qualquer outro pattern. Sempre avalie outras maneiras.</p><ul><li><a href=https://github.com/anhaya/concurrency-with-go/blob/main/pipeline/main.go>https://github.com/anhaya/concurrency-with-go/blob/main/pipeline/main.go</a></li></ul><p><strong>Fan-in/Fan-out</strong></p><p>Imagine a seguinte situação: você precisa gerar métrica de um ano</p><ul><li>Cada mês demora 1 segundo para obter os dados</li><li>Cada mês demora 4 segundos para ser calculado</li><li>Um mês não depende do outro</li></ul><p>Como você implementaria?</p><p>Solução 1: Eu poderia obter os dados de todos os meses e em seguida faria o cálculo em cima dos resultados. Partindo das premissas acima eu levaria 1 min (12s + 48s) para concluir.</p><p>Solução 2: Eu poderia usar uma estratégia de Pipeline aqui, ou seja, ao obter o resultado de um mês eu já começo a calcular de maneira concorrente. Parece bom, melhor que a solução 1.</p><p>Solução 3: Eu poderia remodelar a solução 2, usando a estratégia de Pipeline junto com a de Fanin/Fanout. Ou seja, ao invés de usar somente um worker para fazer o cálculo eu irei usar 4 workers (número aleatório, pode ser mais ou pode ser menos), iniciar mais de um worker para fazer o trabalho é o que chamamos de FanOut, após isso eu junto o resultado disso em um channel só, isso é o que chamamos de FanIn. Em alguns lugares também vemos a mesma abordagem mas como o mesmo nome, coisas como &ldquo;worker pool pattern&rdquo;.</p><ul><li><a href=https://github.com/anhaya/concurrency-with-go/blob/main/fainfanout/main.go>https://github.com/anhaya/concurrency-with-go/blob/main/fainfanout/main.go</a></li></ul><p><strong>Referência</strong></p><p><a href=https://austburn.me/blog/a-better-fan-in-fan-out-example.html>https://austburn.me/blog/a-better-fan-in-fan-out-example.html</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://carlosanhaya.dev/tags/golang/>golang</a></li><li><a href=https://carlosanhaya.dev/tags/concurrency/>concurrency</a></li></ul><nav class=paginav><a class=prev href=https://carlosanhaya.dev/posts/go_order_similarity/><span class=title>« Prev</span><br><span>[Go] Order by similarity</span></a>
<a class=next href=https://carlosanhaya.dev/posts/go_struct_memory/><span class=title>Next »</span><br><span>[Go] Struct e Memória</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share [Go] Patterns de Concorrência on twitter" href="https://twitter.com/intent/tweet/?text=%5bGo%5d%20Patterns%20de%20Concorr%c3%aancia&url=https%3a%2f%2fcarlosanhaya.dev%2fposts%2fgo_concurrency_pattern%2f&hashtags=golang%2cconcurrency"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [Go] Patterns de Concorrência on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fcarlosanhaya.dev%2fposts%2fgo_concurrency_pattern%2f&title=%5bGo%5d%20Patterns%20de%20Concorr%c3%aancia&summary=%5bGo%5d%20Patterns%20de%20Concorr%c3%aancia&source=https%3a%2f%2fcarlosanhaya.dev%2fposts%2fgo_concurrency_pattern%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [Go] Patterns de Concorrência on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fcarlosanhaya.dev%2fposts%2fgo_concurrency_pattern%2f&title=%5bGo%5d%20Patterns%20de%20Concorr%c3%aancia"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [Go] Patterns de Concorrência on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fcarlosanhaya.dev%2fposts%2fgo_concurrency_pattern%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [Go] Patterns de Concorrência on whatsapp" href="https://api.whatsapp.com/send?text=%5bGo%5d%20Patterns%20de%20Concorr%c3%aancia%20-%20https%3a%2f%2fcarlosanhaya.dev%2fposts%2fgo_concurrency_pattern%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [Go] Patterns de Concorrência on telegram" href="https://telegram.me/share/url?text=%5bGo%5d%20Patterns%20de%20Concorr%c3%aancia&url=https%3a%2f%2fcarlosanhaya.dev%2fposts%2fgo_concurrency_pattern%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://carlosanhaya.dev/>Carlos Anhaya</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script></body></html>